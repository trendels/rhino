<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Rhino Documentation</title>
  <link href="./static/favicon.ico" rel="icon" type="image/x-icon">
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="./static/style.css">
</head>
<body>
<header>
<h1 class="title">Rhino Documentation</h1>
</header>
<div id="sidebar">
<a href="./index.html"><img alt="Rhino logo" src="./static/Rhinoceros.svg"></a>
<ul>
<li><a href="./index.html">Documentation</a></li>
<li><a href="./modules/index.html">Module index</a></li>
</ul>
</div>
<nav id="TOC">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#getting-started">Getting started</a><ul>
<li><a href="#hello-world">&quot;Hello, World&quot;</a></li>
<li><a href="#resources-and-mappers">Resources and Mappers</a><ul>
<li><a href="#creating-resources">Creating Resources</a></li>
<li><a href="#named-routes">Named Routes</a></li>
<li><a href="#url-templates">URL Templates</a></li>
<li><a href="#validating-url-parameters">Validating URL parameters</a></li>
<li><a href="#simple-resources">Simple Resources</a></li>
</ul></li>
<li><a href="#accessing-request-data">Accessing request data</a><ul>
<li><a href="#query-parameters">Query parameters</a></li>
<li><a href="#form-fields">Form fields</a></li>
<li><a href="#request-headers">Request headers</a></li>
</ul></li>
<li><a href="#sending-a-response">Sending a response</a><ul>
<li><a href="#building-http-responses">Building HTTP responses</a></li>
<li><a href="#entities">Entities</a></li>
<li><a href="#streaming-responses">Streaming responses</a></li>
<li><a href="#http-exceptions">HTTP Exceptions</a></li>
</ul></li>
<li><a href="#cookies">Cookies</a></li>
<li><a href="#extensions-and-the-context">Extensions and the Context</a></li>
<li><a href="#serving-static-files">Serving static files</a></li>
<li><a href="#using-a-wsgi-server">Using a WSGI Server</a></li>
</ul></li>
<li><a href="#advanced-topics">Advanced Topics</a><ul>
<li><a href="#conditional-requests">Conditional Requests</a><ul>
<li><a href="#etag-and-last-modified-headers"><code>ETag</code> and <code>Last-Modified</code> Headers</a></li>
<li><a href="#generating-etags-automatically">Generating ETags automatically</a></li>
<li><a href="#etags-and-lazy-response-bodies">ETags and lazy response bodies</a></li>
</ul></li>
<li><a href="#content-negotiation">Content Negotiation</a></li>
<li><a href="#representations">Representations</a></li>
<li><a href="#extending">Extending Rhino Applications</a><ul>
<li><a href="#callbacks">Callbacks</a></li>
<li><a href="#wrappers">Wrappers</a></li>
<li><a href="#context-properties">Context Properties</a></li>
</ul></li>
<li><a href="#nesting-mappers">Nesting Mappers</a><ul>
<li><a href="#building-urls-for-nested-resources.">Building URLs for nested resources.</a></li>
</ul></li>
</ul></li>
<li><a href="#api-documentation">API Documentation</a></li>
</ul>
</nav>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Rhino is a python microframework for building RESTful web services.</p>
<p>It aims to ...</p>
<ul>
<li><p>make building small web services as frictionless as possible, while providing features such as conditional request handling, content negotiation and generating URLs out of the box.</p></li>
<li><p>make it easy to extend applications via a standard extension mechanism, to allow building more advanced web applications while keeping the framework core small and simple.</p></li>
<li><p>encourage code re-use by structuring services into small, self-contained applications that can be nested within each other or run as standalone services.</p></li>
</ul>
<p>Rhino is MIT licensed and runs under Python 2.6+. The Source code and bug tracker are hosted at <a href="https://github.com/trendels/rhino">github</a>.</p>
<p><strong>Note: This is a beta release. APIs may change at any time.</strong></p>
</section>
<section id="installation" class="level1">
<h1>Installation</h1>
<p>From pypi:</p>
<pre><code>$ pip install rhino</code></pre>
<p>From a git checkout:</p>
<pre><code>$ git clone https://github.com/trendels/rhino.git
$ cd rhino
$ python setup.py install</code></pre>
<p>To run the test suite, clone the repository as shown above, and run:</p>
<pre><code>$ pip install -r requirements.txt
$ make test</code></pre>
</section>
<section id="getting-started" class="level1">
<h1>Getting started</h1>
<section id="hello-world" class="level2">
<h2>&quot;Hello, World&quot;</h2>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> rhino <span class="ch">import</span> Mapper, get

<span class="ot">@get</span>
<span class="kw">def</span> hello(request):
    <span class="kw">return</span> <span class="st">&quot;hello, world!&quot;</span>

app = Mapper()
app.add(<span class="st">&#39;/&#39;</span>, hello)

<span class="kw">if</span> <span class="ot">__name__</span> == <span class="st">&#39;__main__&#39;</span>:
    app.start_server(<span class="st">&#39;localhost&#39;</span>, <span class="dv">9000</span>)</code></pre>
<p>Run this code and visit <a href="http://localhost:9000/" class="uri">http://localhost:9000/</a> in your browser. You should see text &quot;hello, world!&quot;.</p>
</section>
<section id="resources-and-mappers" class="level2">
<h2>Resources and Mappers</h2>
<section id="creating-resources" class="level3">
<h3>Creating Resources</h3>
<p>Resources are the building blocks or RESTful web services. In Rhino, we create resources using instances of the <a href="./modules/rhino.resource.html#Resource">Resource</a> class:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> rhino <span class="ch">import</span> Resource, Mapper, ok

TODOS = [<span class="st">&quot;Read the Rhino documentation&quot;</span>, <span class="st">&quot;???&quot;</span>, <span class="st">&quot;Profit!&quot;</span>]

todo_list = Resource()

<span class="co"># Register a handler for HTTP GET requests</span>
<span class="ot">@todo_list.get</span>
<span class="kw">def</span> list_todos(request):
    <span class="kw">return</span> ok(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>.join(TODOS))

<span class="co"># Register a handler for HTTP POST requests</span>
<span class="ot">@todo_list.post</span>
<span class="kw">def</span> add_todo(request):
    TODOS.append(request.body.read())
    <span class="kw">return</span> redirect(request.url_for(todo_list))

app = Mapper()
app.add(<span class="st">&#39;/todos&#39;</span>, todo_list)

<span class="kw">if</span> <span class="ot">__name__</span> == <span class="st">&#39;__main__&#39;</span>:
    app.start_server()</code></pre>
<p>The resource's methods are used as decorators to register handler functions. A resource can have handlers for multiple methods, and even multiple handlers for the same method (see <a href="#content-negotiation">Content Negotiation</a>). A handler is a regular Python function that receives the request as its first argument and produces an HTTP response.</p>
<p>Resources are registered with a Mapper under a URL template. The mapper is the entry point for the application, and dispatches incoming requests to resources based on the request URL.</p>
<p>The mapper knows the URLs of all resources, and can also construct URLs. This functionality is exposed through the <a href="./modules/rhino.request.html#Request.url_for">Request.url_for()</a> method, as seen in the example above. This avoids having hardcoded URLs in different places of the code that are hard to change later.</p>
</section>
<section id="named-routes" class="level3">
<h3>Named Routes</h3>
<p>When building URLs, it may not always be possible or practical to refer to resources directly. For this reason, routes can be assigned a unique name in <a href="./modules/rhino.mapper.html#Mapper.add">Mapper.add()</a> by which they can be referred to later:</p>
<pre class="sourceCode python"><code class="sourceCode python">mapper.add(<span class="st">&#39;/todos&#39;</span>, todo_list, name=<span class="st">&#39;todos&#39;</span>)

<span class="co"># Now we can refer to the route like this:</span>
request.url_for(todo_list)

<span class="co"># As well as this:</span>
request.url_for(<span class="st">&#39;todos&#39;</span>)</code></pre>
<p>These special route names are predefined:</p>
<ul>
<li><p><code class="sourceCode python">request.url_for(<span class="st">&#39;.&#39;</span>)</code> refers to the current route itself.</p></li>
<li><p><code class="sourceCode python">request.url_for(<span class="st">&#39;/&#39;</span>)</code> refers to the root level of the app, which may not be identical with the root level of the server, depending on how the app is hosted.</p></li>
</ul>
</section>
<section id="url-templates" class="level3">
<h3>URL Templates</h3>
<p>URL templates used with the mapper can contain parameters and ranges:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> rhino.errors <span class="ch">import</span> NotFound

todo_item = Resource()

<span class="ot">@todo_item.get</span>
<span class="kw">def</span> show_item(request, item_id):
    <span class="kw">try</span>:
        item = TODOS[<span class="dt">int</span>(item_id)]
    <span class="kw">except</span> <span class="ot">IndexError</span>:
        <span class="kw">raise</span> NotFound(<span class="st">&quot;Todo item with id </span><span class="ot">%s</span><span class="st"> not found.&quot;</span> % item_id)
    <span class="kw">return</span> ok(<span class="st">&quot;Information about todo item &#39;</span><span class="ot">%s</span><span class="st">&#39;.&quot;</span> % item)

app.add(<span class="st">&#39;/todos/{item_id:digits}&#39;</span>, todo_item)</code></pre>
<p>In this example, the part of the URL path after '/todos/' will be extracted and passed as a named argument <code>item_id</code> to the <code>show_item</code> handler. It is also required to contain only digits or the route won't match. See <a href="./modules/rhino.mapper.html#rhino.mapper"><code>rhino.mapper</code></a> for a list of default range names.</p>
<p>When building a URL for a route who's template contains URL parameters, all required parameters must be provided as keyword arguments to <a href="./modules/rhino.request.html#Request.url_for">Request.url_for()</a>. The arguments don't need to be strings, but their string representation must match the parameter's range (<code>digits</code>, in this case):</p>
<pre class="sourceCode python"><code class="sourceCode python">request.url_for(todo_item, item_id=<span class="dv">1</span>)      <span class="co"># -&gt; http://localhost/items/1</span>
request.url_for(todo_item, item_id=<span class="st">&#39;foo&#39;</span>)  <span class="co"># raises InvalidArgumentError</span></code></pre>
<p>For appending a query string to the generated URL, use the special <code>_query</code> parameter:</p>
<pre class="sourceCode python"><code class="sourceCode python">request.url_for(todo_list, _query={<span class="st">&#39;foo&#39;</span>: <span class="dv">1</span>}) <span class="co"># -&gt; http://localhost/items?foo=1</span></code></pre>
</section>
<section id="validating-url-parameters" class="level3">
<h3>Validating URL parameters</h3>
<p>In resources which expect URL parameters, the parameter often refers to a internal object that is required for answering the request, such as a row in a database. Instead of fetching the object in each handler and exiting with an error if it doesn't exist, you can register a special <code>from_url</code> handler to do this in one place:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ot">@todo_item.from_url</span>
<span class="kw">def</span> item_from_url(request, item_id):
    <span class="kw">try</span>:
        item = TODOS[<span class="dt">int</span>(item_id)]
    <span class="kw">except</span> <span class="ot">IndexError</span>:
        <span class="kw">raise</span> NotFound(<span class="st">&quot;Todo item with id </span><span class="ot">%s</span><span class="st"> not found.&quot;</span> % item_id)
    <span class="kw">return</span> {<span class="st">&#39;item&#39;</span>: item}</code></pre>
<p>The handler is called before the actual request handler, and must return a new dictionary, which replaces the URL parameters passed to the handler. Alternatively it can stop further processing by raising an HTTPException (See <a href="#http-exceptions">HTTP Exceptions</a>).</p>
<p>In resources supporting many request methods, this simplifies handlers considerably:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Continued from above ...</span>

<span class="ot">@todo_item.get</span>
<span class="kw">def</span> show_item(request, item):  <span class="co"># Instead of item_id, we now get an item</span>
    <span class="kw">return</span> ok(<span class="st">&quot;Information about todo item </span><span class="ot">%s</span><span class="st">&quot;</span> item)

<span class="ot">@todo_item.put</span>
<span class="kw">def</span> update_item(request, item):
    <span class="co"># update item ...</span>

<span class="ot">@todo_item.delete</span>
<span class="kw">def</span> delete_item(request, item):
    <span class="co"># delete item ...</span></code></pre>
</section>
<section id="simple-resources" class="level3">
<h3>Simple Resources</h3>
<p>As the &quot;Hello, world&quot; example shows, there are some common shortcuts:</p>
<ul>
<li><p>If a resource only handles one HTTP method (usually GET), which is quite common, you can create a standalone handler function using one of the decorators <a href="./modules/rhino.resource.html#get">get()</a>, <a href="./modules/rhino.resource.html#post">post()</a>, <a href="./modules/rhino.resource.html#put">put()</a>, <a href="./modules/rhino.resource.html#patch">patch()</a>, <a href="./modules/rhino.resource.html#delete">delete()</a> or <a href="./modules/rhino.resource.html#options">options()</a>.</p></li>
<li><p>Instead of a <a href="./modules/rhino.response.html#Response">Response</a>, you can also return an arbitrary object that will be sent as the response body, using a default status code of &quot;200 OK&quot;.</p></li>
</ul>
</section>
</section>
<section id="accessing-request-data" class="level2">
<h2>Accessing request data</h2>
<p>The request data from the WSGI environment is stored in a <a href="./modules/rhino.request.html#Request">Request</a> instance.</p>
<section id="query-parameters" class="level3">
<h3>Query parameters</h3>
<p>Request parameters are stored as a <a href="./modules/rhino.request.html#QueryDict">QueryDict</a> in the <code>query</code> property:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Example: given a query string of &#39;a=b&amp;id=1&amp;id=2&#39;</span>
request.query[<span class="st">&#39;a&#39;</span>]                   <span class="co"># -&gt; &#39;a&#39;</span>
request.query.get(<span class="st">&#39;name&#39;</span>, <span class="st">&#39;default&#39;</span>) <span class="co"># -&gt; &#39;default&#39;</span>
request.query.get_all(<span class="st">&#39;id&#39;</span>)          <span class="co"># -&gt; [&#39;1&#39;, &#39;2&#39;]</span></code></pre>
</section>
<section id="form-fields" class="level3">
<h3>Form fields</h3>
<p>The <code>form</code> property holds form fields as a <a href="./modules/rhino.request.html#QueryDict">QueryDict</a>. It is parsed when it is first accessed during a request using the stdlib's <code>cgi.FieldStorage</code> class.</p>
<p>File upload fields from multipart forms have the extra attributes 'filename', 'type' and 'file':</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Accessing a regular form field</span>
username = request.form[<span class="st">&#39;username&#39;</span>]

<span class="co"># Accessing a file upload field</span>
client_filename = request.form[<span class="st">&#39;upload&#39;</span>].filename
content_type = request.form[<span class="st">&#39;upload&#39;</span>].<span class="dt">type</span>
file_data = request.form[<span class="st">&#39;upload&#39;</span>].<span class="dt">file</span>.read()</code></pre>
</section>
<section id="request-headers" class="level3">
<h3>Request headers</h3>
<p>The <code>headers</code> property contains a dict-like object that provides case-insensitive access to the request headers. Also, accessing a non-existing request header returns <code class="sourceCode python"><span class="ot">None</span></code> instead of raising <code class="sourceCode python"><span class="ot">KeyError</span></code>:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co"># The following are equivalent:</span>
request.headers[<span class="st">&#39;user-agent&#39;</span>]
request.headers[<span class="st">&#39;USER-AGENT&#39;</span>]
request.headers.get(<span class="st">&#39;User-Agent&#39;</span>)</code></pre>
<p>For more request properties, see the API documentation for <a href="./modules/rhino.request.html#Request">Request</a>.</p>
</section>
</section>
<section id="sending-a-response" class="level2">
<h2>Sending a response</h2>
<section id="building-http-responses" class="level3">
<h3>Building HTTP responses</h3>
<p>To return a response from a handler function, use one of the helper functions (<a href="./modules/rhino.response.html#ok">ok()</a>, <a href="./modules/rhino.response.html#created">created()</a>, <a href="./modules/rhino.response.html#no_content">no_content()</a>, <a href="./modules/rhino.response.html#redirect">redirect()</a> or <a href="./modules/rhino.response.html#response">response()</a>), or construct a <a href="./modules/rhino.response.html#Response">Response</a> instance directly. The helper functions allow passing headers as keyword arguments, and accept non-string values for <code>etag</code>, <code>last_modified</code>, and <code>expires</code> (See <a href="./modules/rhino.response.html#response">response()</a> for details).</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> rhino <span class="ch">import</span> response, ok, redirect

<span class="co"># Common response codes</span>
ok(<span class="st">&#39;hello&#39;</span>)                          <span class="co"># 200 OK</span>
redirect(<span class="st">&#39;/foo/bar&#39;</span>)                 <span class="co"># 302 Found</span>
redirect(code=<span class="dv">303</span>, location=<span class="st">&#39;/quux&#39;</span>) <span class="co"># 303 See Other</span>

<span class="co"># Custom responses</span>
response(code=<span class="dv">418</span>, body=<span class="st">&quot;I&#39;m a teapot!&quot;</span>, x_tea=<span class="st">&quot;Earl Grey&quot;</span>)</code></pre>
<p>Setting response headers:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Create a response with header &#39;Content-Type: application/json&#39;</span>
ok(json.dumps({<span class="st">&#39;status&#39;</span>: <span class="st">&#39;green&#39;</span>}), content_type=<span class="st">&#39;application/json&#39;</span>)

<span class="co"># Create a response with headers:</span>
<span class="co">#   Expires: &lt;http date 5 minutes in the future&gt;</span>
<span class="co">#   X-Powered-By: my-app-version</span>
ok(<span class="st">&#39;hello, world!&#39;</span>, expires=<span class="dv">300</span>, x_powered_by=<span class="st">&#39;my-app-version&#39;</span>)</code></pre>
</section>
<section id="entities" class="level3">
<h3>Entities</h3>
<p>Instead of manually specifying a Content-Type header, it is often easier to have the content-producing function return a <a href="./modules/rhino.response.html#Entity">Entity</a> instead, which represents a response body with entity headers, but no status code:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> rhino <span class="ch">import</span> Entity

<span class="kw">def</span> json_entity(obj):
    <span class="kw">return</span> Entity(body=json.dumps(obj), content_type=<span class="st">&#39;application/json&#39;</span>)

<span class="ot">@get</span>
<span class="kw">def</span> get_status(request):
    <span class="kw">return</span> json_entity({<span class="st">&#39;status&#39;</span>: <span class="st">&#39;supergreen&#39;</span>})</code></pre>
<p>The <a href="./modules/rhino.response.html#Entity">Entity</a> constructor accepts the same keyword arguments as <a href="./modules/rhino.response.html#response">response()</a>.</p>
<p>When used as a response body, the entity body and headers will be used to populate the response. Headers passed to the response directly take precedence and can override entity headers if needed:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ot">@get</span>
<span class="kw">def</span> get_legacy_status(request):
    <span class="kw">return</span> ok(json_entity({<span class="st">&#39;status&#39;</span>: <span class="st">&#39;green&#39;</span>}), content_type=<span class="st">&#39;text/x-json&#39;</span>)</code></pre>
</section>
<section id="streaming-responses" class="level3">
<h3>Streaming responses</h3>
<p>Returning an iterator will cause the response to be streamed using chunked transfer encoding, if implemented by the WSGI server:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ot">@get</span>
<span class="kw">def</span> chunked_response(request):
    <span class="kw">return</span> ok(chunk <span class="kw">for</span> chunk in [<span class="st">&#39;one&#39;</span>, <span class="st">&#39;two&#39;</span>, <span class="st">&#39;three&#39;</span>])</code></pre>
<p>When paired with an asynchronous WSGI server, such as <code>gevent.wsgi.WSGIServer</code>, this can be used for long-polling handlers or <a href="http://www.w3.org/TR/eventsource/">Server-Sent Events</a>:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">import</span> gevent
<span class="ch">from</span> rhino.util <span class="ch">import</span> sse_event

<span class="co"># Send an event with &#39;data: ping&#39; every five seconds.</span>
<span class="ot">@get</span>(provides=<span class="st">&#39;text/event-stream&#39;</span>)
<span class="kw">def</span> event_stream(request):
    <span class="kw">while</span> <span class="ot">True</span>:
        <span class="kw">yield</span> sse_event(data=<span class="st">&#39;ping&#39;</span>)
        gevent.sleep(<span class="dv">5</span>)</code></pre>
</section>
<section id="http-exceptions" class="level3">
<h3>HTTP Exceptions</h3>
<p>Sometimes it is useful to stop further processing of a request from a place where you cannot simply return a response, such as a callback or a <code>from_url</code> handler. For this reason, responses that are errors or redirects (3xx, 4xx, 5xx) can also be generated by raising subclasses of <a href="./modules/rhino.errors.html#HTTPException">HTTPException</a>:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> rhino.errors <span class="ch">import</span> NotFound

<span class="ot">@get</span>
<span class="kw">def</span> get_user(request, name):
    user = get_user_from_database(name=name)
    <span class="kw">if</span> not user:
        <span class="kw">raise</span> NotFound(<span class="st">&quot;The user could not be found.&quot;</span>)
    <span class="kw">return</span> ok(<span class="st">&quot;Information about user </span><span class="ot">%s</span><span class="st">&quot;</span> %  user.name)</code></pre>
<p>Some common HTTP Exceptions are defined in the <a href="./modules/rhino.errors.html#rhino.errors"><code>rhino.errors</code></a> module, as well as base classes for the different types of errors that can be subclassed to create new kinds.</p>
<p><strong>Note</strong>: By convention, the Rhino documentation and code examples use exceptions for all HTTP errors (4xx and 5xx), even if they occur in a request handler, and regular response objects for everything else.</p>
</section>
</section>
<section id="cookies" class="level2">
<h2>Cookies</h2>
<p>Incoming cookies are stored as a dictionary in the <a href="./modules/rhino.request.html#Request.cookies">Request.cookies</a> attribute. Outgoing cookies can be set and deleted using the <a href="./modules/rhino.response.html#Response.set_cookie">Response.set_cookie()</a> and <a href="./modules/rhino.response.html#Response.delete_cookie">Response.delete_cookie()</a> methods.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Accessing a request cookie</span>
request.cookies.get(<span class="st">&#39;user-font-size&#39;</span>, <span class="st">&#39;12px&#39;</span>)

<span class="co"># Setting a cookie</span>
resp = ok()
resp.set_cookie(<span class="st">&#39;color&#39;</span>, <span class="st">&#39;green&#39;</span>, max_age=<span class="dv">3600</span>, httponly=<span class="ot">True</span>)</code></pre>
<p>Note that only strings can be used as cookie values. For anything but the most simple use cases, you should probably use the <a href="./modules/rhino.ext.session.html#rhino.ext.session"><code>rhino.ext.session</code></a> extension instead.</p>
</section>
<section id="extensions-and-the-context" class="level2">
<h2>Extensions and the Context</h2>
<p>The primary extension mechanism is the <a href="./modules/rhino.mapper.html#Context">Context</a>. This is an object that is created for each request, and has the same lifetime as the <a href="./modules/rhino.request.html#Request">Request</a> object.</p>
<p>The context can be requested in a handler using dependency injection. To receive the context, add an argument named <code>ctx</code> to the handler function's signature (by convention, this should be the 2nd argument after the request, although unlike the request, the context is always passed in by name).</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ot">@get</span>
<span class="kw">def</span> hello_with_ctx(request, ctx):
    <span class="co"># This handler has access to the context ...</span></code></pre>
<p>By default, the context is empty, and only serves as an interface to install <a href="#callbacks">Callbacks</a>. However, it can be extended by using the <a href="./modules/rhino.mapper.html#Mapper.add_ctx_property">Mapper.add_ctx_property()</a> method:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ot">@get</span>
<span class="kw">def</span> hello_with_ctx(request, ctx):
    <span class="kw">return</span> ok(<span class="st">&quot;The app name is </span><span class="ot">%s</span><span class="st">&quot;</span> % ctx.app_name)

app = Mapper()
app.add_ctx_property(<span class="st">&#39;app_name&#39;</span>, <span class="st">&quot;My Application&quot;</span>)
app.add(<span class="st">&#39;/&#39;</span>, hello_with_ctx)</code></pre>
<p>In this example, all context instances within this Mapper will have an 'app_name' attribute containing the string &quot;My Application&quot;. Usually, the second argument to <code>add_ctx_property</code> will be a factory function to provide a lazily initialized property. See <a href="#extending">Extending Rhino Applications</a> for details.</p>
<p>Some default extensions are included to add common functionality. These usually require additional python modules to be installed (those are listed at the top of the extension's documentation)</p>
<ul>
<li><a href="./modules/rhino.ext.jinja2.html#rhino.ext.jinja2"><code>rhino.ext.jinja2</code></a> -- Extension for rendering jinja templates.</li>
<li><a href="./modules/rhino.ext.session.html#rhino.ext.session"><code>rhino.ext.session</code></a> -- Cookie-based session support, and other backends provided by beaker.session.</li>
<li><a href="./modules/rhino.ext.sqlalchemy.html#rhino.ext.sqlalchemy"><code>rhino.ext.sqlalchemy</code></a> -- Provides a lazily initialized sqlalchemy Session object via the context.</li>
</ul>
<p>Here is an example app using jinja2 templates and cookie-based sessions. Save the following code to a file named <code>webapp.py</code>:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> rhino <span class="ch">import</span> Mapper, get
<span class="ch">from</span> rhino.ext.jinja2 <span class="ch">import</span> JinjaRenderer
<span class="ch">from</span> rhino.ext.session <span class="ch">import</span> CookieSession

app = Mapper()
app.add_ctx_property(<span class="st">&#39;render_template&#39;</span>, JinjaRenderer(<span class="st">&#39;.&#39;</span>))
app.add_ctx_property(<span class="st">&#39;session&#39;</span>, CookieSession(secret=<span class="st">&#39;my-session-secret&#39;</span>))

<span class="ot">@get</span>
<span class="kw">def</span> index(request, ctx):
    counter = ctx.session.get(<span class="st">&#39;counter&#39;</span>, <span class="dv">0</span>)
    ctx.session[<span class="st">&#39;counter&#39;</span>] = counter + <span class="dv">1</span>
    <span class="kw">return</span> ctx.render_template(<span class="st">&#39;index.html&#39;</span>, visits=counter)

app.add(<span class="st">&#39;/&#39;</span>, index)

<span class="kw">if</span> <span class="ot">__name__</span> == <span class="st">&#39;__main__&#39;</span>:
    app.start_server()</code></pre>
<p>And the <code>index.html</code> template:</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="dt">&lt;!DOCTYPE </span>html<span class="dt">&gt;</span>
<span class="kw">&lt;html&gt;</span>
  <span class="kw">&lt;body&gt;</span>
    <span class="kw">&lt;h1&gt;</span>Welcome!<span class="kw">&lt;/h1&gt;</span>
    <span class="kw">&lt;p&gt;</span>You have visited this site {{ visits }} times.<span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;/body&gt;</span>
<span class="kw">&lt;/html&gt;</span></code></pre>
<p>To test the application, first make sure the prerequisites are installed:</p>
<pre><code>$ pip install beaker jinja2</code></pre>
<p>Then start the development server:</p>
<pre><code>$ python webapp.py
Server listening at http://localhost:9000/</code></pre>
<p>Point your browser at <a href="http://localhost:9000/" class="uri">http://localhost:9000/</a> and reload the page a few times, and you should see the counter go up.</p>
</section>
<section id="serving-static-files" class="level2">
<h2>Serving static files</h2>
<p>To serve static files, you can use the <a href="./modules/rhino.static.html#StaticDirectory">StaticDirectory</a> and <a href="./modules/rhino.static.html#StaticFile">StaticFile</a> resources:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> rhino <span class="ch">import</span> Mapper, StaticDirectory, StaticFile

app = Mapper()
app.add(<span class="st">&#39;/favicon.ico&#39;</span>, StaticFile(<span class="st">&#39;./favicon.ico&#39;</span>))
app.add(<span class="st">&#39;/static/{path:any}&#39;</span>, StaticDirectory(<span class="st">&#39;./static/&#39;</span>), name=<span class="st">&#39;static&#39;</span>)</code></pre>
</section>
<section id="using-a-wsgi-server" class="level2">
<h2>Using a WSGI Server</h2>
<p>For production uses, you should run the app using a WSGI server of your choice.</p>
<p>The mappers <a href="./modules/rhino.mapper.html#Mapper.wsgi">Mapper.wsgi()</a> method is the WSGI entry point. For example, to run <a href="#hello-world">the &quot;hello, world&quot; example</a> using the <a href="http://gunicorn.org/">gunicorn</a> WSGI server, save the code to a file named <code>hello.py</code> and run</p>
<pre><code>$ gunicorn --bind=localhost:8000 hello:app.wsgi</code></pre>
</section>
</section>
<section id="advanced-topics" class="level1">
<h1>Advanced Topics</h1>
<section id="conditional-requests" class="level2">
<h2>Conditional Requests</h2>
<section id="etag-and-last-modified-headers" class="level3">
<h3><code>ETag</code> and <code>Last-Modified</code> Headers</h3>
<p>If you add an <code>ETag</code> or <code>Last-Modified</code> header to a response, Rhino will automatically handle conditional GET and HEAD requests. The easiest way to do this is to use <a href="./modules/rhino.response.html#response">response()</a> or related functions:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ot">@get</span>
<span class="kw">def</span> resource_with_etag(request):
    <span class="kw">return</span> ok(<span class="st">&quot;hello, world&quot;</span>, etag=<span class="st">&quot;hello-v1&quot;</span>)

<span class="ch">from</span> datetime <span class="ch">import</span> datetime

<span class="ot">@get</span>
<span class="kw">def</span> resource_with_last_modified(request):
    <span class="kw">return</span> ok(<span class="st">&quot;hello, world&quot;</span>, last_modified=datetime.now())</code></pre>
<p>Note that you don't have to put quotes around the ETag value, as they will be added automatically (but you can if you want). In most cases, ETag is preferable to a Last-Modified, since the HTTP date format only has 1-second precision.</p>
</section>
<section id="generating-etags-automatically" class="level3">
<h3>Generating ETags automatically</h3>
<p>An easy way to generate ETags is to compute a hash over the entire response body, e.g. an HTML page. This way you can be sure the ETag changes whenever anything on the page has changed. There is a shortcut to do this in Rhino, by passing a callable to the <code>etag</code> argument of <a href="./modules/rhino.response.html#response">response()</a>. The callable will be called immediately with the request body to produce an ETag.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> hashlib <span class="ch">import</span> sha1

<span class="kw">def</span> sha1_etag(s):
    <span class="kw">return</span> sha1(s.encode(<span class="st">&#39;utf-8&#39;</span>)).hexdigest()

<span class="ot">@get</span>
<span class="kw">def</span> resource_with_sha1_etag(request):
    <span class="kw">return</span> ok(<span class="st">&quot;hello, world!&quot;</span>, etag=sha1_etag)</code></pre>
</section>
<section id="etags-and-lazy-response-bodies" class="level3">
<h3>ETags and lazy response bodies</h3>
<p>Simply adding ETags headers to outgoing responses can already save considerable bandwidth, but with the examples we've seen so far, the entire response is still generated on the server for each request. If a representation is expensive to produce, it can be beneficial to pre-compute ETags, and try to handle conditional requests on the basis of the ETag header alone, and only producing the response body when it actually needs to be sent over the wire.</p>
<p>For this reason, Rhino allows you to wrap any valid response body in a callable, that will be called only if needed:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ot">@get</span>
<span class="kw">def</span> resource_with_precomputed_etag(request):
    etag = get_etag()  <span class="co"># Cheap: e.g a cache lookup</span>
    <span class="kw">def</span> body():  <span class="co"># Will only be called for response codes != &quot;304 Not Modified&quot;</span>
        <span class="kw">return</span> expensive_operation()
    <span class="kw">return</span> ok(body, etag=etag)</code></pre>
</section>
</section>
<section id="content-negotiation" class="level2">
<h2>Content Negotiation</h2>
<p>If a resource is able to produce representations in different formats, or different versions of the same format, you can use Content-Negotiation. All handler decorators (<a href="./modules/rhino.resource.html#get">get()</a>, <a href="./modules/rhino.resource.html#Resource.get">Resource.get()</a>), etc. allow you to specify <code>provides</code> and <code>accepts</code> arguments for this purpose.</p>
<p>The value of <code>provides</code> should be a single, fully-qualified mime-type, (e.g. <code>text/plain</code>, <code>application/json</code>), that will be matched with the <code>Accept</code> headers sent by the client to find the best representation available.</p>
<p>The value of <code>accepts</code> can be a media-range, such as <code>text/*</code>, or a mime-type like <code>provides</code>.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">import</span> json

greeting = Resource()

<span class="ot">@greeting.get</span>(provides=<span class="st">&#39;text/plain; charset=utf-8&#39;</span>)
<span class="kw">def</span> greeting_text(request):
    <span class="kw">return</span> ok(<span class="st">&quot;hello, world&quot;</span>)

<span class="ot">@greeting.get</span>(provides=<span class="st">&#39;application/json&#39;</span>)
<span class="kw">def</span> greeting_text(request):
    <span class="kw">return</span> ok(json.dumps({<span class="st">&quot;message&quot;</span>: <span class="st">&quot;hello, world&quot;</span>}))</code></pre>
<p>A few important things to note:</p>
<ul>
<li><p>Content-Negotiation on the basis of the <code>Accept</code> header is only enabled if all handlers of a resource that are taken into consideration (i.e. with the matching HTTP method) are annotated with the mime-type they provide (via <code>provides</code>). For other handlers, there is no way for the framework to predict what mime-type they might produce. In this case, the framework will only consider the handler(s) that are <em>not</em> annotated to be present.</p></li>
<li><p>If a handler has a <code>provides</code> annotation, and no Content-Type is explicitly set on the response, the value of the <code>provides</code> header will be used by default.</p></li>
<li><p>A handler that has no <code>accepts</code> annotation will be treated as if it accepts <code>*/*</code> (i.e. anything).</p></li>
</ul>
</section>
<section id="representations" class="level2">
<h2>Representations</h2>
<p>Instead of choosing handlers using Content-Negotiation, you can also define &quot;Representations&quot;. In Rhino, a representation is any object that has &quot;provides&quot; an &quot;serialize&quot; attributes (if used for output), and/or &quot;accepts&quot; and &quot;deserialize&quot; (if used for input). Representations are used with the <code>produces</code> nd <code>consumes</code> arguments to handler decorators. They provide Content-Negotiation, just like <code>accepts</code>/<code>provides</code>, but also methods to serialize the response body or deserialize the request body on demand.</p>
<p>Here is an example of a generic JSON representation:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">import</span> json

<span class="kw">class</span> json_repr(<span class="dt">object</span>):
    accepts = <span class="st">&#39;application/json&#39;</span>
    provides = <span class="st">&#39;application/json&#39;</span>

    <span class="ot">@staticmethod</span>
    <span class="kw">def</span> serialize(obj):
        <span class="kw">return</span> json.dumps(obj, sort_keys=<span class="ot">True</span>)

    <span class="ot">@staticmethod</span>
    <span class="kw">def</span> deserialize(f):
        <span class="kw">return</span> json.loads(f.read())</code></pre>
<p>And a resource which produces and consumes this representation:</p>
<pre class="sourceCode python"><code class="sourceCode python">greeting = Resource()
greeting.message = <span class="st">&quot;hello, world!&quot;</span>

<span class="ot">@greeting.get</span>(produces=json_repr)
<span class="kw">def</span> get_json(request):
    <span class="kw">return</span> {<span class="st">&#39;message&#39;</span>: greeting.message}

<span class="ot">@greeting.put</span>(consumes=json_repr, produces=json_repr)
<span class="kw">def</span> put_json(request):
    <span class="kw">try</span>:
        greeting.message = request.body[<span class="st">&#39;text&#39;</span>]
    <span class="kw">except</span> <span class="ot">ValueError</span>:
        <span class="kw">raise</span> BadReqeust
    <span class="kw">return</span> {<span class="st">&#39;message&#39;</span>: greeting.message}</code></pre>
<p>Representations are useful if you want to provide different versions of a custom content-type.</p>
<!-- TODO which handler is the default here? Also add this info to notes on
     Content-Negotiation above -->
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> v1_repr(<span class="dt">object</span>):
    produces = <span class="st">&#39;application/vnd.myorg.document+json;v=1&#39;</span>
    <span class="co"># ...</span>

<span class="kw">class</span> v2_repr(<span class="dt">object</span>):
    produces = <span class="st">&#39;application/vnd.myorg.document+json;v=1&#39;</span>
    <span class="co"># ...</span>

<span class="co"># etc.</span>

<span class="ot">@get</span>(produces=v1_repr)
<span class="ot">@get</span>(produces=v2_repr)
<span class="kw">def</span> document_json(request):
    doc = get_document()
    <span class="kw">return</span> doc</code></pre>
</section>
<section id="extending" class="level2">
<h2>Extending Rhino Applications</h2>
<section id="callbacks" class="level3">
<h3>Callbacks</h3>
<p>Callbacks are functions that can be installed on the <a href="./modules/rhino.mapper.html#Context">Context</a> and that are called by the framework at different stages during request processing. See <a href="./modules/rhino.mapper.html#Context.add_callback">Context.add_callback()</a> for more information.</p>
</section>
<section id="wrappers" class="level3">
<h3>Wrappers</h3>
<p>A wrapper is a kind of middleware that wraps a mapper and has full control over how request processing proceeds. It can inspect the incoming request, decide whether to pass them on to the mapped wrapper, and modify the response. See <a href="./modules/rhino.mapper.html#Mapper.add_wrapper">Mapper.add_wrapper()</a> for details.</p>
</section>
<section id="context-properties" class="level3">
<h3>Context Properties</h3>
<p>The Context can be extended via the <a href="./modules/rhino.mapper.html#Mapper.add_ctx_property">Mapper.add_ctx_property()</a> method.</p>
</section>
</section>
<section id="nesting-mappers" class="level2">
<h2>Nesting Mappers</h2>
<p>To build re-usable applications, or to structure larger applications into smaller parts, mappers can be nested:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> rhino <span class="ch">import</span> Mapper

<span class="ch">import</span> app_one
<span class="ch">import</span> app_two

main_app = Mapper()
main_app.add(<span class="st">&#39;/one|&#39;</span>, app_one, name=<span class="st">&#39;one&#39;</span>)
main_app.add(<span class="st">&#39;/two|&#39;</span>, app_two, name=<span class="st">&#39;two&#39;</span>)</code></pre>
<p>The <code>|</code> marker at the end of the pattern causes the pattern to only be matched against the beginning of <code>PATH_INFO</code>. The rest of the path will be preserved and consumed by nested mappers.</p>
<section id="building-urls-for-nested-resources." class="level3">
<h3>Building URLs for nested resources.</h3>
<p>Building URLs for routes in other mappers that are nested under a common root is possible if all routes on the way have a name.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ot">@get</span>
<span class="kw">def</span> hello1(request):
    <span class="kw">return</span> <span class="st">&#39;hello 1&#39;</span>

<span class="ot">@get</span>
<span class="kw">def</span> hello2(request):
    <span class="kw">return</span> <span class="st">&#39;hello 2&#39;</span>

red_mapper = Mapper()
red_mapper.add(<span class="st">&#39;/hello&#39;</span>, hello1, name=<span class="st">&#39;hello&#39;</span>)

green_mapper = Mapper()
green_mapper.add(<span class="st">&#39;/hello&#39;</span>, hello2, name=<span class="st">&#39;hello&#39;</span>)

red_mapper.add(<span class="st">&#39;/green|&#39;</span>, green_mapper, name=<span class="st">&#39;green&#39;</span>)

root_mapper = Mapper()
root_mapper.add(<span class="st">&#39;/red|&#39;</span>, red_mapper, name=<span class="st">&#39;red&#39;</span>)</code></pre>
<p>This creates the following URL structure (only resources are shown):</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">URL</th>
<th style="text-align: left;">Resource</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">/red/hello</td>
<td style="text-align: left;"><code>hello1</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">/red/green/hello</td>
<td style="text-align: left;"><code>hello2</code></td>
</tr>
</tbody>
</table>
<p>From anywhere within the app, a URL the <code>hello1</code> and <code>hello2</code> resources can be can be created like this, using the absolute path starting at <code>root_mapper</code>:</p>
<pre class="sourceCode python"><code class="sourceCode python">request.url_for(<span class="st">&#39;/red.hello&#39;</span>)        <span class="co"># for hello1</span>
request.url_for(<span class="st">&#39;/red.green.hello&#39;</span>)  <span class="co"># for hello2</span></code></pre>
<p>Using a relative path, we can build a URL for <code>hello2</code> from within <code>hello1</code> like this:</p>
<pre class="sourceCode python"><code class="sourceCode python">request.url_for(<span class="st">&#39;green.hello&#39;</span>)</code></pre>
<p>And from within <code>hello2</code>, the URL for <code>hello1</code> like this:</p>
<pre class="sourceCode python"><code class="sourceCode python">request.url_for(<span class="st">&#39;..hello&#39;</span>)</code></pre>
<p>The last two cases would keep working even if <code>red_mapper</code> is run as a standalone app, or nested under a different mapper. See <a href="./modules/rhino.request.html#Request.url_for">Request.url_for()</a> for more information.</p>
<!--
   More topics to cover (in no particular order):

   - Unicode, default_encoding and default_content_type
   - more ways to build resources (classes, objects, non-handler functions)
   - views
-->
</section>
</section>
</section>
<section id="api-documentation" class="level1">
<h1>API Documentation</h1>
<p><a href="modules/index.html">Module Index</a></p>
</section>
</body>
</html>
